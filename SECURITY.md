# Документация по безопасности

## Оглавление

1. [Система авторизации](#система-авторизации)
2. [Хранение данных пользователя](#хранение-данных-пользователя)
3. [Проверка авторизации](#проверка-авторизации)
4. [Защита от атак](#защита-от-атак)
5. [Рекомендации по безопасности](#рекомендации-по-безопасности)

---

## Система авторизации

### Обзор

Сайт использует авторизацию через Telegram Bot API с одноразовыми токенами. Все защищенные API endpoints проверяют авторизацию на сервере.

### Процесс авторизации

1. **Генерация токена**
   - Пользователь запрашивает авторизацию на сайте
   - Генерируется одноразовый токен (64 hex символа)
   - Токен сохраняется в БД с статусом `"waiting"` и сроком действия 10 минут

2. **Подтверждение через бота**
   - Пользователь переходит к боту по ссылке `https://t.me/bot?start=auth_<token>`
   - Бот валидирует токен в БД
   - Бот сохраняет данные пользователя в БД (`users` таблица)
   - Бот привязывает `telegram_id` к токену и меняет статус на `"used"`
   - Бот перенаправляет пользователя на `/auth/callback?token=<token>`

3. **Авторизация на сайте**
   - Сайт получает токен из URL
   - Проверяет токен в БД (`auth_tokens` таблица)
   - Проверяет, что токен использован и привязан к пользователю
   - Проверяет, что токен еще не был использован на сайте (`site_used_at === null`)
   - Устанавливает `site_used_at` (атомарная операция)
   - Возвращает данные пользователя
   - Сохраняет `userData` в `localStorage`

---

## Хранение данных пользователя

### Структура userData

```typescript
interface TelegramUser {
  id: number;              // Telegram ID пользователя
  first_name: string;      // Имя пользователя
  last_name?: string;      // Фамилия (опционально)
  username?: string;       // @username (опционально)
  photo_url?: string;      // URL фото профиля (опционально)
  auth_date: number;       // Unix timestamp авторизации
  hash: string;            // Токен авторизации (64 hex символа)
}
```

### Где хранится

- **Клиент**: В `localStorage` браузера под ключом `telegram_user` (JSON строка)
- **Сервер**: В БД Supabase в таблицах:
  - `users` — данные пользователя (`id`, `tg_id`, `first_name`, `last_name`, `username`, `photo_url`)
  - `auth_tokens` — токены авторизации (`token`, `status`, `telegram_id`, `site_used_at`, `expires_at`)

### Что передается в API

При каждом запросе к защищенному API endpoint передается `userData` в теле запроса:

```json
{
  "userData": {
    "id": 123456789,
    "first_name": "Иван",
    "hash": "abc123...",
    "auth_date": 1234567890
  },
  // ... другие данные запроса
}
```

---

## Проверка авторизации

### Уровни проверки

#### 1. Базовая проверка структуры (клиент)

```typescript
// lib/auth.ts
validateTelegramAuth(data: any): boolean {
  if (!data || !data.id || !data.first_name || !data.hash) {
    return false;
  }
  return true;
}
```

Это проверка только структуры данных, **НЕ** проверка подлинности. Используется для быстрой проверки на клиенте.

#### 2. Проверка токена (сервер)

**Endpoint**: `/api/validateTelegramAuth`

Проверяет:
- ✅ Токен существует в БД (`auth_tokens` таблица)
- ✅ Токен имеет статус `"used"` (бот обработал его)
- ✅ Токен привязан к `telegram_id` (совпадает с `userData.id`)
- ✅ Токен еще не использован на сайте (`site_used_at === null`) — **одноразовость**
- ✅ Данные не старше 24 часов (`auth_date` проверка)

#### 3. Проверка владения ресурсом (сервер)

Все защищенные endpoints дополнительно проверяют, что ресурс принадлежит пользователю:

```typescript
// Пример: /api/payments/cancel
if (payment.user_id !== auth.userId) {
  return NextResponse.json({ error: "Payment does not belong to this user" }, { status: 403 });
}
```

---

## Защита от атак

### 1. Подделка userData (Spoofing)

**Атака**: Злоумышленник подделывает `userData` в `localStorage` или запросе.

**Защита**:
- ✅ Сервер проверяет токен в БД
- ✅ Токен должен существовать и быть использован ботом
- ✅ Токен привязан к `telegram_id`

**Вывод**: Простая подделка `userData` не работает, т.к. токен проверяется в БД.

### 2. Перехват токена (Man-in-the-Middle)

**Атака**: Злоумышленник перехватывает `userData` из сетевого запроса.

**Защита**:
- ✅ Токен одноразовый (`site_used_at` устанавливается после первого использования)
- ✅ После использования токена повторное использование невозможно
- ✅ Токен привязан к конкретному `telegram_id`

**Вывод**: Даже если токен перехвачен, использовать его нельзя.

### 3. Replay атака

**Атака**: Повторное использование старых данных авторизации.

**Защита**:
- ✅ Проверка `auth_date` (данные не старше 24 часов)
- ✅ Одноразовость токена (`site_used_at` проверка)
- ✅ Токен имеет срок действия (`expires_at` — 10 минут)

**Вывод**: Старые данные авторизации не работают.

### 4. XSS атака (Cross-Site Scripting)

**Атака**: Внедрение вредоносного JavaScript для кражи `userData` из `localStorage`.

**Защита**:
- ✅ Содержимое фильтруется через React (защита от XSS)
- ✅ Используется `Content-Security-Policy` (если настроен)
- ✅ Токен одноразовый — даже если украден, использовать нельзя
- ✅ Сервер проверяет токен — украденные данные не пройдут проверку

**Рекомендация**: Добавить CSP заголовки для дополнительной защиты.

### 5. CSRF атака (Cross-Site Request Forgery)

**Атака**: Выполнение запросов от имени авторизованного пользователя с другого сайта.

**Текущая защита**:
- ⚠️ Ограниченная — `userData` должен быть передан в запросе

**Рекомендация**: 
- Добавить CSRF токены
- Использовать SameSite cookies
- Проверять Origin/Referer заголовки

### 6. SQL Injection / NoSQL Injection

**Защита**:
- ✅ Используется Supabase (параметризованные запросы)
- ✅ Все запросы через ORM, не через строки

**Вывод**: Защищено на уровне ORM.

### 7. Несанкционированный доступ к ресурсам

**Защита**:
- ✅ Все защищенные endpoints проверяют владельца ресурса
- ✅ `user_id` проверяется перед выполнением операций

**Пример**:
```typescript
// /api/payments/cancel
if (payment.user_id !== auth.userId) {
  return NextResponse.json({ error: "Forbidden" }, { status: 403 });
}
```

---

## Рекомендации по безопасности

### ✅ Уже реализовано

1. **Одноразовые токены**
   - Токены можно использовать только один раз
   - Проверка `site_used_at` предотвращает повторное использование

2. **Срок действия токенов**
   - Токены действительны 10 минут (при генерации)
   - Данные авторизации действительны 24 часа

3. **Проверка на сервере**
   - Все защищенные endpoints проверяют авторизацию
   - Проверка владения ресурсом (resource ownership)

4. **Атомарные операции**
   - Использование токена происходит атомарно (проверка `site_used_at === null` + обновление)

5. **Валидация данных**
   - Проверка структуры данных на клиенте
   - Строгая проверка токена на сервере

### ⚠️ Рекомендуется добавить

1. **HTTPS везде**
   - Всегда использовать HTTPS в production
   - Не допускать HTTP соединений

2. **Content-Security-Policy (CSP)**
   ```http
   Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline' https://telegram.org; style-src 'self' 'unsafe-inline';
   ```

3. **Rate Limiting**
   - Ограничение количества запросов к `/api/validateTelegramAuth`
   - Ограничение генерации токенов

4. **Логирование безопасности**
   - Логировать все неудачные попытки авторизации
   - Мониторинг подозрительной активности

5. **CSRF защита**
   - Добавить CSRF токены для форм
   - Проверять Origin/Referer заголовки

6. **Секретные ключи**
   - Хранить `TELEGRAM_BOT_TOKEN`, `YOOKASSA_SECRET_KEY` только в переменных окружения
   - Не коммитить секреты в Git
   - Использовать разные ключи для dev/production

7. **Валидация входных данных**
   - Проверять все входные данные на сервере
   - Санитизировать пользовательский ввод

8. **Ограничение IP адресов**
   - Для webhook endpoints (уже реализовано для YooKassa)
   - Для admin endpoints

---

## Защищенные API Endpoints

### Требуют авторизации (userData):

1. **`POST /api/subscriptions`**
   - Получение подписок пользователя
   - Проверка: `userData` + владелец подписок

2. **`POST /api/createPayment`**
   - Создание платежа
   - Проверка: `userData` + соответствие `userId`

3. **`POST /api/payments/cancel`**
   - Отмена платежа
   - Проверка: `userData` + владелец платежа

4. **`GET /api/payments?paymentId=xxx`**
   - Получение платежа
   - Проверка: `userData` (в query) + владелец платежа

5. **`POST /api/payment/checkStatus`**
   - Проверка статуса платежа
   - Проверка: `userData` + владелец платежа

### Не требуют авторизации:

1. **`POST /api/telegramAuth`** — вход в систему (получение токена)
2. **`POST /api/validateTelegramAuth`** — проверка авторизации
3. **`POST /api/generateAuthToken`** — генерация токена
4. **`POST /api/payment/webhook`** — webhook от YooKassa (защита по IP)
5. **`GET /api/payment/success`** — редирект после оплаты
6. **`GET /api/payment/fail`** — редирект при ошибке оплаты
7. **`GET /api/plans`** — публичная информация о тарифах
8. **`POST /api/promocodes/validate`** — публичная валидация промокодов

---

## Процесс проверки авторизации

### Схема проверки

```
┌─────────────┐
│   Client    │
│  (Browser)  │
└──────┬──────┘
       │
       │ 1. Запрос с userData
       │
       ▼
┌─────────────────────────────────────┐
│  /api/validateTelegramAuth          │
│  (проверка токена)                  │
└──────┬──────────────────────────────┘
       │
       │ 2. Проверка в БД
       │
       ▼
┌─────────────────────────────────────┐
│  auth_tokens table                  │
│  - token существует?                │
│  - status === "used"?               │
│  - telegram_id совпадает?           │
│  - site_used_at === null?           │
└──────┬──────────────────────────────┘
       │
       │ 3. Результат
       │
       ▼
┌─────────────────────────────────────┐
│  Защищенный Endpoint                │
│  - Проверка владения ресурсом       │
│  - Выполнение операции              │
└─────────────────────────────────────┘
```

---

## Примеры уязвимостей и защита

### ❌ НЕ БЕЗОПАСНО

```typescript
// Плохо: проверка только на клиенте
const user = JSON.parse(localStorage.getItem("telegram_user"));
if (user && user.id) {
  // Разрешить доступ
}
```

**Проблема**: Любой может подделать данные в `localStorage`.

### ✅ БЕЗОПАСНО

```typescript
// Хорошо: проверка на сервере
const { userData } = await request.json();
const auth = await validateAuthFromData(userData, request.url);

if (!auth.isValid) {
  return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
}

// Дополнительная проверка владения ресурсом
if (payment.user_id !== auth.userId) {
  return NextResponse.json({ error: "Forbidden" }, { status: 403 });
}
```

**Защита**: Сервер проверяет токен в БД и владение ресурсом.

---

## Мониторинг и логирование

### Что логировать

1. **Неудачные попытки авторизации**
   - Неверный токен
   - Использованный токен
   - Истекший токен

2. **Подозрительная активность**
   - Множественные запросы с одного IP
   - Попытки доступа к чужим ресурсам
   - Необычные паттерны запросов

3. **Webhook события**
   - Все webhook запросы от YooKassa
   - Обработка платежей

### Где логировать

- Server logs (консоль)
- Supabase logs (если используется)
- Отдельный сервис мониторинга (например, Sentry)

---

## Чеклист безопасности

### При развертывании

- [ ] Все переменные окружения установлены
- [ ] HTTPS настроен
- [ ] `TELEGRAM_BOT_TOKEN` не коммитится в Git
- [ ] `YOOKASSA_SECRET_KEY` не коммитится в Git
- [ ] CSP заголовки настроены
- [ ] Rate limiting включен
- [ ] Логирование безопасности включено

### При разработке

- [ ] Все защищенные endpoints проверяют авторизацию
- [ ] Проверка владения ресурсом реализована
- [ ] Валидация входных данных
- [ ] Нет SQL injection уязвимостей
- [ ] XSS защита (React по умолчанию защищает)
- [ ] HTTPS используется везде

---

## Контакты

При обнаружении уязвимости безопасности, пожалуйста, сообщите об этом через:
- Email: security@vlesser.ru
- Telegram: @support

**НЕ публикуйте уязвимости публично до исправления!**

---

## Обновления

- **2025-01-XX**: Добавлена система одноразовых токенов
- **2025-01-XX**: Реализована проверка владения ресурсом
- **2025-01-XX**: Добавлена проверка IP для webhook endpoints

